<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>MINECRAFT_JS_CLONE</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: sans-serif; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); color: white; font-size: 24px; pointer-events: none; }
        #hotbar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
        .slot { width: 50px; height: 50px; border: 2px solid #555; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; }
        .active { border-color: white; background: rgba(255,255,255,0.2); }
    </style>
</head>
<body>
    <div id="crosshair">+</div>
    <div id="hotbar">
        <div id="s1" class="slot active" style="background: #4caf50;">1</div>
        <div id="s2" class="slot" style="background: #795548;">2</div>
        <div id="s3" class="slot" style="background: #9e9e9e;">3</div>
    </div>

    <script>
        let scene, camera, renderer, raycaster;
        let moveState = { fwd: false, bwd: false, l: false, r: false, jump: false };
        let velocity = new THREE.Vector3();
        let blocks = [], currentBlockType = 0x4caf50; // Herbe par défaut

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(5, 10, 5);

            const light = new THREE.AmbientLight(0xffffff, 0.7);
            const sun = new THREE.DirectionalLight(0xffffff, 0.5);
            sun.position.set(10, 20, 10);
            scene.add(light, sun);

            // GÉNÉRATION TERRAIN INITIAL (10x10)
            for(let x = 0; x < 10; x++) {
                for(let z = 0; z < 10; z++) {
                    addBlock(x, 0, z, 0x4caf50);
                }
            }

            raycaster = new THREE.Raycaster();
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // CONTROLES
            document.body.onclick = () => document.body.requestPointerLock();
            window.onkeydown = (e) => handleKey(e.code, true, e.key);
            window.onkeyup = (e) => handleKey(e.code, false, e.key);
            
            document.addEventListener('mousemove', (e) => {
                if(document.pointerLockElement) {
                    camera.rotation.y -= e.movementX * 0.002;
                    camera.rotation.x -= e.movementY * 0.002;
                    camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                }
            });

            window.onmousedown = (e) => {
                if(!document.pointerLockElement) return;
                raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                const intersects = raycaster.intersectObjects(blocks);

                if(intersects.length > 0) {
                    const intersect = intersects[0];
                    if(e.button === 0) { // CLIC GAUCHE : Détruire
                        scene.remove(intersect.object);
                        blocks = blocks.filter(b => b !== intersect.object);
                    } else if(e.button === 2) { // CLIC DROIT : Poser
                        const pos = intersect.object.position.clone().add(intersect.face.normal);
                        addBlock(pos.x, pos.y, pos.z, currentBlockType);
                    }
                }
            };
            // Empêcher le menu contextuel sur clic droit
            window.oncontextmenu = (e) => e.preventDefault();
        }

        function addBlock(x, y, z, col) {
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.MeshStandardMaterial({ color: col })
            );
            mesh.position.set(x, y, z);
            scene.add(mesh);
            blocks.push(mesh);
        }

        function handleKey(code, val, key) {
            if(code === 'KeyW' || code === 'KeyZ') moveState.fwd = val;
            if(code === 'KeyS') moveState.bwd = val;
            if(code === 'KeyA' || code === 'KeyQ') moveState.l = val;
            if(code === 'KeyD') moveState.r = val;
            if(code === 'Space') moveState.jump = val;
            
            if(val && ['1','2','3'].includes(key)) {
                document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
                document.getElementById('s'+key).classList.add('active');
                if(key === '1') currentBlockType = 0x4caf50; // Herbe
                if(key === '2') currentBlockType = 0x795548; // Terre
                if(key === '3') currentBlockType = 0x9e9e9e; // Pierre
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // PHYSIQUE
            const speed = 0.1;
            const dir = new THREE.Vector3();
            if(moveState.fwd) dir.z -= 1;
            if(moveState.bwd) dir.z += 1;
            if(moveState.l) dir.x -= 1;
            if(moveState.r) dir.x += 1;
            
            dir.applyQuaternion(camera.quaternion);
            dir.y = 0;
            camera.position.addScaledVector(dir.normalize(), speed);

            // Gravité et Saut simple
            velocity.y -= 0.01;
            if(moveState.jump && camera.position.y <= 2) velocity.y = 0.15;
            camera.position.y += velocity.y;

            if(camera.position.y < 1.8) {
                camera.position.y = 1.8;
                velocity.y = 0;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
